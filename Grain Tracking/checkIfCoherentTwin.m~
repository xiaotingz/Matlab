% function mask_ctwin = checkIfCoherentTwin(file, face_to_calc, thres_g, thres_n)
% ############################################################################
% * Input 
%     - face_to_calc = [n, 2], labels of the grain faces of interest.
%     - thres_norm, the threshold for angle between face_avg_norm and [111]
%  * Output
%     - mask_ctwin = [n, 1]
%  * Notes
%     - Mainly designed to check if twins are coherent or not. Use together
%     with getFaceRFvecs.m
% ############################################################################
% % ------------------ load data for debug --------------------
file = ('/Users/xiaotingzhong/Desktop/Datas/Ni_an4_5/An4new6_fixedOrigin_smooth.dream3d');
load('181107_mig_piececorresp_comb','tracked_uniqueface_an4')
load('181108_data', 'rfvecs_an4')
face_to_calc = tracked_uniqueface_an4;
rfvecs = rfvecs_an4;
thres_g = 0.06;
thres_n = 10;
clear rfvecs_an4 tracked_uniqueface_an4
% %-----------------------------------------------------------
% ##### Load and Clean Data #####
facelabel = double(h5read(file,'/DataContainers/TriangleDataContainer/FaceData/FaceLabels')).';
tri_normal = double(h5read(file,'/DataContainers/TriangleDataContainer/FaceData/FaceNormals'))';
EA = double(h5read(file,'/DataContainers/ImageDataContainer/CellFeatureData/AvgEulerAngles'))';
EA(1,:) = [];
EA = rad2deg(EA);
mask_inner = all(facelabel > 0, 2);
facelabel = facelabel(mask_inner, :);
tri_normal = tri_normal(mask_inner, :);

% ##### Prepare Symmetry Matrix #####
O = CrysSym;
n_sym = size(O, 3);
O = reshape(O(:), 3*3, n_sym);
O = [reshape(O(1:3, :), [], 1), reshape(O(4:6, :), [], 1), reshape(O(7:9, :), [], 1)];

% ##### Prepare Coherent Twin Normal #####
% ----- ref : https://github.com/BlueQuartzSoftware/DREAM3D/blob/develop/Source/Plugins/OrientationAnalysis/OrientationAnalysisFilters/FindGBCDMetricBased.cpp -----
normal_ctwin_1 = [1,1,1]';
normal_ctwin_1 = normal_ctwin_1/sqrt(3);
g_twin = AAToG(60, [1,1,1]);
normal_ctwin_2 = g_twin' * normal_ctwin_1;
rfvec_twin = normal_ctwin_1' * tand(60/2);

normal_ctwin_1 = repmat(normal_ctwin_1, 1, n_sym)';
normal_ctwin_2 = repmat(normal_ctwin_2, 1, n_sym)';
% normal_ctwin_vari = reshape(O * normal_ctwin_1, 3, n_sym)';
% normal_ctwin_vari = unique(normal_ctwin_vari, 'rows');
% normal_ctwin_mat = normal_ctwin_vari(:);
% normal_ctwin_mat = repmat(normal_ctwin_mat, 1, n_sym)';
% normal_ctwin_mat = reshape(normal_ctwin_mat, [], 3);

% ##### First Filter Out non-twin Misorientations #####
rfvec_twin = repmat(rfvec_twin, size(face_to_calc, 1), 1);
%%
% [rfvecs]  = getFaceRFvecs(file, face_to_calc);
mask_ctwin = vecnorm(rfvecs - rfvec_twin, 2, 2) < thres_g;

% ##### Then Check Plane Normals #####
angle_diff_list = [];
% angle_diff_all = [];
angle_diff_cnt = [];
id_list = [];

% """
% Note the symmetry matrixes are transposed this way. But the group should
% stay the same. 
% """
parfor i = 1:length(face_to_calc)
    disp(i)
    if mask_ctwin(i)
        % ----- Get triangle normals in sample frame -----
        grain_A = face_to_calc(i, 1);
        grain_B = face_to_calc(i, 2);
%         grain_A = 590;
%         grain_B = 729;
        mask_objface = (facelabel(:,1) == grain_A & facelabel(:,2) == grain_B |...
            facelabel(:,1) == grain_B & facelabel(:,2) == grain_A);
        facetri_normal = tri_normal(mask_objface, :);
        angle_diffs = ones(size(facetri_normal, 1), 1)*90;

        % ----- Convert triangle normals to crystal frame and apply symmetries -----
%         g1 = reshape(G(face_to_calc(i, 1), :), 3,3)';
%         g2 = reshape(G(face_to_calc(i, 2), :), 3,3)';
        g1 = EAtoG(EA(grain_A, :));
        g2 = EAtoG(EA(grain_B, :));
        gg1 = O * g1;
        gg2 = O * g2;
        
        for j = 1:size(facetri_normal, 1)
            normal = facetri_normal(j, :)';
            % ##### Min Angle ##### 
            normal_g1 = reshape(gg1 * normal, 3, n_sym)';
            % ----- dist to (111) -----
%             ang_diff_tmp1 = acosd(dot(normal_g1, normal_ctwin_1, 2));
            % ----- dist to {111} family -----
            normal_g1 = repmat(normal_g1, size(normal_ctwin_vari, 1), 1);
            ang_diff_tmp1 = acosd(dot(normal_g1, normal_ctwin_mat, 2));
            if min(ang_diff_tmp1) < angle_diffs(j)
                angle_diffs(j) = min(ang_diff_tmp1);
            end
            normal_g2 = reshape(gg2 * normal, 3, n_sym)';
            % ----- dist to (111) -----
%             ang_diff_tmp2 = acosd(dot(normal_g2, normal_ctwin_2, 2));
            % ----- dist to {111} family -----
            normal_g2 = repmat(normal_g2, size(normal_ctwin_vari, 1), 1);
            ang_diff_tmp2 = acosd(dot(normal_g2, normal_ctwin_mat, 2));
            if min(ang_diff_tmp2) < angle_diffs(j)
                angle_diffs(j) = min(ang_diff_tmp2);
            end
        end
        
        angle_diff_all = [angle_diff_all; ang_diff_tmp1; ang_diff_tmp2];
        angle_diff_list = [angle_diff_list; angle_diffs];
%         angle_diff_cnt = [angle_diff_cnt; sum(mask_objface)];
%         id_list = [id_list; i];
        
        % ##### Check if Angle Within Threshold #####
        if sum(angle_diffs < thres_n) < length(angle_diffs)*0.8
            mask_ctwin(i) = false;            
        end
    end
end
  
figure
histogram(angle_diff_list,'Normalization','probability')
set(gca, 'FontSize', 18);
xlabel('angle between triangle normals & \{111\}', 'FontSize', 18)
print('all plane normal variants to {111}, all angles, twins','-dpng','-r300')

%%
% ##### Shown Coherent triangles on twin face #####
obj_facelabel_an4 = face_to_calc(i, :);
color1 = [0, 0.4470, 0.7410];
load('/Users/xiaotingzhong/Desktop/Datas/Ni_an4_5/181107.mat','tri_node_an4', 'node_coord_an4')
tri_centr = double(h5read(file,'/DataContainers/TriangleDataContainer/FaceData/FaceCentroids'))';
tri_centr = tri_centr(mask_inner, :);

tri_connect = tri_node_an4(mask_objface, :);

figure
trisurf(tri_connect, node_coord_an4(:,1), node_coord_an4(:,2), node_coord_an4(:,3),'Facecolor',color1, 'Facealpha', 0.3, 'edgealpha', 0.3);
hold on
trisurf(tri_connect(angle_diffs < 10, :), node_coord_an4(:,1), node_coord_an4(:,2), node_coord_an4(:,3),'Facecolor',color1, 'Facealpha', 1, 'edgealpha', 1);
rotate3d on
% quiver3(tri_centr(mask_objface,1),tri_centr(mask_objface,2),tri_centr(mask_objface,3), ...
%      facetri_normal(:,1),facetri_normal(:,2),facetri_normal(:,3),1.5,'color','r');

daspect([1 1 1])

%%
% ##### Save Coherent Twin Figure #####
FFId = 3071;
name = ['gA_', num2str(grain_A), '_gB_', num2str(grain_B), '_FFId_', num2str(FFId), '_B']
print(name,'-dpng','-r300')



%%
file_g = '/Users/xiaotingzhong/Desktop/Datas/Ni_an4_5/An4new6_fixedOrigin_smooth_OrientMat.dream3d';
G = double(h5read(file_g,'/DataContainers/ImageDataContainer/CellFeatureData/AvgOrientMat'))';
% ----- G in D3D follow row first order -----
G(1, :) = [];



%%
% % ##### Random Normals, V1 #####
% [x,y,z] = sphere(100);
% sample_pts = [x(:), y(:), z(:)];
% sample_pts = test./vecnorm(test, 2, 2);
% angle_diffs = ones(size(sample_pts, 1), 1)*90;
% figure
% surf(x,y,z)

% ##### Random Normals, Kryz #####
n_sample_pts = 500000;
sample_pts = zeros(n_sample_pts, 3);
inc = pi * (3 - sqrt(5));
off = 2.0 / n_sample_pts;
for i = 1:n_sample_pts
    y = i * off - 1.0 + 0.5*off;
    r = sqrt(max(0.0, 1.0 - y^2));
    phi = i * inc;
    z = sin(phi) * r;
    
    if z > 0
        sample_pts(i, 1) = cos(phi)*r;
        sample_pts(i, 2) = y;
        sample_pts(i, 3) = z;
    end
end
sample_pts(sum(sample_pts,2)==0, :) = [];

figure
scatter3(sample_pts(:,1), sample_pts(:,2), sample_pts(:,3));
daspect([1 1 1])
print('uniform sampled_pts','-dpng','-r300')

% ##### Normal Distance as Angle #####
% angle_diffs = ones(size(sample_pts, 1), 1)*90;
% for i = 1:size(sample_pts, 1)
%     normal = sample_pts(i, :)';
%     normal = repmat(normal, 1, 8)';
%     ang_diff_1 = abs(atan2d(vecnorm(cross(normal, normal_ctwin_vari), 2, 2), dot(normal, normal_ctwin_vari, 2)));
%     if min(ang_diff_1) < angle_diffs(i)
%         angle_diffs(i) = min(ang_diff_1);
%     end
% end
normal_ctwin_vari = reshape(O * normal_ctwin_1(1,:)', 3, n_sym)';
normal_ctwin_vari = unique(normal_ctwin_vari, 'rows');
normal_ctwin_mat = normal_ctwin_vari(:);
normal_ctwin_mat = repmat(normal_ctwin_mat, 1, n_sym)';
normal_ctwin_mat = reshape(normal_ctwin_mat, [], 3);

% ang_diff_nosym = acosd(dot(sample_pts, normal_ctwin_mat, 2));
% 
% figure
% histogram(ang_diff_nosym,'Normalization','probability')
% set(gca, 'FontSize', 18);
% xlabel('uniform normals, no sym, angle distance to \{111\}', 'FontSize', 18)

ang_diffs_sym = zeros(size(sample_pts, 1), 1);
for i = 1:size(sample_pts, 1)
    normal = sample_pts(i,:)';
    normal = reshape(O * normal, 3, n_sym)';
    normal = repmat(normal, size(normal_ctwin_vari, 1), 1);
    ang_diff_tmp = acosd(dot(normal, normal_ctwin_mat, 2));
    ang_diffs_sym(i) = min(ang_diff_tmp);
end

figure
histogram(ang_diffs_sym,'Normalization','probability')
set(gca, 'FontSize', 18);
xlabel('uniform normals, sym\_min, angle distance to \{111\}', 'FontSize', 18)
print('uniform sampled_pts angle distance to {111} v2','-dpng','-r300')



